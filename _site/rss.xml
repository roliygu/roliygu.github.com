<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Mon, 11 Aug 2014 23:30:10 +0800</pubDate>
    <lastBuildDate>Mon, 11 Aug 2014 23:30:10 +0800</lastBuildDate>

    
    <item>
      <title>Roliy机器学习de资源目录</title>
      <link>place_your_blog_url_here/ml/2014/07/25/MLres.html</link>
      <pubDate>25 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ml/2014/07/25/MLres</guid>
      <description>&lt;p&gt;这里是Roliy的机器学习相关资源和推荐的地方~&lt;/p&gt;

&lt;h2&gt;书籍&lt;/h2&gt;

&lt;h4&gt;不得不说,个人看过的ML的书真是一只手就能数过来,这里就说说个人非常喜欢的一些吧&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://book.douban.com/subject/10590856/&quot;&gt;统计学习方法&lt;/a&gt;&lt;/strong&gt;,李航的这本&lt;code&gt;又小又薄&lt;/code&gt;的书满满的都是算法,对于简单粗暴、就喜欢算法和怎么实现的我来说,简直再适合不过了。加之其中用到的数学推导过程基本上不超过CS的数学范畴,看起来也不啥费劲。力荐之~&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;论文&lt;/h2&gt;

&lt;h2&gt;网站&lt;/h2&gt;

&lt;h4&gt;有些是个人blog,有些是...&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://beader.me/mlnotebook/&quot;&gt;机器学习基石-笔记&lt;/a&gt;,blog主的名字不太清楚,但是这套笔记的质量很高,内容概括得也很全,推荐之~&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;数据集&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Roliy常用的Git命令</title>
      <link>place_your_blog_url_here/sf/2014/07/25/Git.html</link>
      <pubDate>25 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/sf/2014/07/25/Git</guid>
      <description>&lt;p&gt;这里是Roliy的Git命令备忘录,不是很适合新手.对于想学Git的爱好者,强烈推荐&lt;a href=&quot;http://book.douban.com/subject/4813786/&quot;&gt;版本控制之道&lt;/a&gt;.你会找到你需要的东西~&lt;/p&gt;

&lt;h3&gt;安装之后初始化&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;config --global user.name &amp;quot;XXXXXXX&amp;quot;               # set username
config --global user.email &amp;quot;XXXX@XXX.com&amp;quot;         # set email
config --global --list                            # 显示全局设置
config --global color.ui &amp;quot;auto&amp;quot;/&amp;quot;false&amp;quot;/&amp;quot;true&amp;quot;    # 使用不同颜色显示不同类型的内容
config --global core.editor gvim.exe              # 将gvim设置为commit留言调用的编辑器,前提是gvim已经在环境变量里了
git config --global merge.tool kdiff3
git config --global mergetool.kdiff3.path &amp;quot;C:\Program Files\KDiff3\kdiff3.exe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建仓库和提交更新&lt;/h3&gt;

&lt;p&gt;个人理解：Git管理了三个空间,一个是实际硬盘空间/工作区,直接修改源文件的地方;一个是暂存区,也就是执行了add命令之后文件存在的地方;最后一个是版本仓库,也就是使用了commit命令之后文件存在的地方.   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mkdir foldername                #这个是命令行创建文件夹命令嘛
cd foldername
git init                        #在文件夹目录下新建仓库
git add filename.xx             #把文件添加到仓库中,前提是该文件在目录下
git commit -m &amp;quot;add in hello&amp;quot;    #提交更  
在源文件修改之后使用：
git status                      #查看修改状态,会有红色标注,这时候使用：
git add index.html              #再使用git status,文件会变成绿色,这时候使用：
git commit -m &amp;quot;add &amp;lt;head&amp;gt; and &amp;lt;title&amp;gt; to index&amp;quot;
add -i                          #进入交互模式,详解
1:status    2:update    3:revert    4:add untracked
5:patch     6:diff      7:quit      8:help
add untracked   #添加未被git跟踪的文件到暂存区
updata          #将被修改的文件(已被跟踪)加进暂存区
revert          #将暂存区中的文件去掉,相当于取消add操作
patch           #针对文件中被修改的块执行添加缓冲区询问和操作
add -p          #直接进入patch模式
git stash       #将当前工作区的修改推入栈中,工作区还原成最近一次commit的状态          
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分支&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git checkout -b x1 x2           #从x1分支创建x2分支,并切换到x2,与下两条指令合在一起等价
git branch x1 x2                #从父分支x2创建分支x1，没有使用切换分支指令前，修改源文件,提交：
git checkout x1                 #切换到之前创建的分支x1,这里认为,切换分支之前的修改提交是作用于“创建了x1分支的x2分支上
                                #的”而x1分支则完全是x2分支(未修改)的拷贝.当然,如果修改发生在切换分支之后,则又不一样
                                #了.切换到未修改的分支之后,所有源文件将会回复到原来状态.切换分支之后的修改相当于在“回
                                #到过去”的原文件上修改.
git checkout master             
git rebase x1                   #将x1分支上的所有提交复制到当前分支上,此命令执行后,当前分支和x1分支一模一样
git branch -d x1                #然后就可以删除x1分支了,大写D更强力一些
git branch                      #显示分支名称,带*号的是当前分支
git tag 1.0 x1                  #第一个参数是版本号,第二个参数是分支名.整个标签的意思是给(截至到目前所有文件修改到)
                                #x1分支做一个版本号标记
git tag                         #查看所有版本号
git branch x1.1 1.0             #从标签1.0创建分支x1.1
git merge x2                    #将x2分支的所有修改合并到当前分支
                                #原文件状态是X,创建两条分支X1和X2,并在分支上修改,若要将X和X1或X2合并,则OK,若X1和X2分支
                                #对同一个文件做了修改,将X1和X2合并时就会产生冲突.
git mergr --squash x2           #相当于仅把x2分支内容提交到暂存区,之后还需要commit指令提交  
git branch -m name1 name2       #把name1改成name2,大写的M更强力
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;版本回溯&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git revert 版本号                #撤销修改,版本号最好是前一个提交的版本号,这样不用处理冲突...
git reset --hard 版本号  复位操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;打包&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git archive --format=zip --prefix=mysite-1.0/1.0 | gzip &amp;gt; mysite-1.0.zip
git archive --format=tar --prefix=mysite-1.0/1.0 | gzip &amp;gt; mysite-1.0.tar.gz
#两种打包压缩,第一种压缩成zip第二种压缩成gz;format的参数表明压缩类型,prefix参数表明目标目录,最后一部分表明压缩文件名称
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看日志&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git log                         #查看修改日志,可以加上&amp;#39;-具体数字&amp;#39;参数表示需要显示的条数
git log -p                      #按照日志顺序显示版本间差异
git log number                  #根据哈希码查看日志,前七位即可
git log --since=&amp;quot;5 hours&amp;quot;       #查看5个小时内的提交记录
git log number1...number2       #查看版本number1到number2之间的版本记录
git blame file                  #按行输出file,每行前面会写该行提交的版本号和提交者,提交时间等
git blame -L number1,number2 file #查看num1到num2行的记录
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;文件开始状态为X1,修改之后为X2,此时使用add命令;再次修改源文件,状态为X3;也就是说版本库里文件是X1状态,暂存区文件是X2状态,实际硬盘上是X3状态,使用：
git diff                        #将暂存区文件X2和硬盘文件X3做比较
git diff --cached               #将暂存区X2和版本库X1做比较
git diff head                   #将硬盘X3和版本库X1做比较
git diff number                 #number是版本号,将当前状态和该版本比较
git mv name1 name2              #将文件名name1改成name2,相当于(在硬盘上改名,并执行了add指令),但仍需要conmit指令提交到版本库
初始状态为X,提交之后需要修改X,但是需要把两次修改作为一次提交(比如一些错误比较低级,不想让别人知道)：
git commit -C head -a -amend
git reset HEAD                  #复位HEAD提交,相当与删除了最新的一个提交记录,实际文件没有什么变化
git gc                          #整理版本库,清理一些垃圾,根据提交日志,日志里没有的东西都会被删除.比如,之前复位了一些版本,文件还存在于硬盘上,执行本操作之后就复位的日志记录之后的修改都被删除了.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;设置.gitignore文件&lt;/h3&gt;

&lt;p&gt;通过设置.gitignore文件来忽略跟踪满足特定规则的文件
Windows下命名为 .gitignore.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fd1/*           忽略所有名字是fd1的目录下的全部内容
filename*       忽略所有filenameXXX的文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;冲突&lt;/h3&gt;

&lt;p&gt;当合并或其他时候就会遇到冲突,下面是某文本块冲突的实例&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;xxx
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:filename
    This is an apple
=====
    This is a banana
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; filename
xxx
一对&amp;#39;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;#39;和&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;#39;将冲突的文本块标记出来,&amp;#39;====&amp;#39;将修改后和修改前分割开
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改量少的话,可以直接依据上面的提示做编辑,复杂的话,使用    &lt;code&gt;git mergetool&lt;/code&gt; 打开合并工具,图形化合并文件.&lt;/p&gt;

&lt;h3&gt;网络通信&lt;/h3&gt;

&lt;h4&gt;三种方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;SSH  git@github.com:roliygu/RoliyOS.git 安全&lt;/li&gt;
&lt;li&gt;git  git://github.com/roliygu/RoliyOS.git 据说速度最快&lt;/li&gt;
&lt;li&gt;HTTP https://github.com/roliygu/RoliyOS.git 需要修改防火墙,不过我用着没改&lt;/li&gt;
&lt;li&gt;pull和fetch的区别,前者从远程仓库取过来并合并到本地分支,后者只是取过来更新远程分支&lt;/li&gt;
&lt;li&gt;pull命令带两个参数,远程版本库名称&lt;code&gt;origin&lt;/code&gt;即可,合并到本地分支&lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Welcome to Jekyll!</title>
      <link>place_your_blog_url_here/sf/2014/07/24/welcome-to-jekyll.html</link>
      <pubDate>24 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/sf/2014/07/24/welcome-to-jekyll</guid>
      <description>&lt;p&gt;You&amp;#39;ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory - edit this post and re-build (or run with the &lt;code&gt;-w&lt;/code&gt; switch) to see your changes!
To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention: YYYY-MM-DD-name-of-post.ext.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll&amp;#39;s GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>