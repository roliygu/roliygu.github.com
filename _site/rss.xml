<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Wed, 13 Aug 2014 10:04:36 +0800</pubDate>
    <lastBuildDate>Wed, 13 Aug 2014 10:04:36 +0800</lastBuildDate>

    
    <item>
      <title>CPP备忘录</title>
      <link>place_your_blog_url_here/pl/2014/08/12/CPP.html</link>
      <pubDate>12 Aug 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/pl/2014/08/12/CPP</guid>
      <description>&lt;h2&gt;程序设计实践笔记&lt;/h2&gt;

&lt;h3&gt;函数指针&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;类型 (*指针变量名)(参数类型1, 参数类型2,...);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例如,快速排序&lt;code&gt;qsort&lt;/code&gt;的第三个参数就是函数指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int min(int a,int b){return a&amp;lt;b;}
int (*pf)(int, int);
pf = min;
pf(1,2)             //函数指针名(实参表)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;C语言中的qsort函数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void qsort(void *base, int nelem, unsigned int width,int(*pfCompare)(const void *,const void *))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较函数编写规则

&lt;ul&gt;
&lt;li&gt;elem1排在elem2前面,返回值为负整数&lt;/li&gt;
&lt;li&gt;相等,返回0&lt;/li&gt;
&lt;li&gt;排在后面,返回正整数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-CPP&quot; data-lang=&quot;CPP&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myCompare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#define Num 5&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;qsort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myCompare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;命令行参数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;argc:代表命令行参数的个数,包括程序名;&lt;/li&gt;
&lt;li&gt;argv:指针数组,其中每个元素都是一个&lt;code&gt;char *&lt;/code&gt;,argv[i]指向第i个参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int main(int argc, char *argv[]){
    xxx;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;位运算(6种)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n = n &amp;amp; 0xffffff00;&lt;/code&gt; 将低8位置成0&lt;/li&gt;
&lt;li&gt;n&amp;amp;=0xff00; n是short型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x &amp;amp; 0x80 == 0x80&lt;/code&gt; x的第8位是否为1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n ^= 0xff&lt;/code&gt; 低8位取反&lt;/li&gt;
&lt;li&gt;a^b=c 那么 c^b=a,c^a=b&lt;/li&gt;
&lt;li&gt;~位取反&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;引用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;定义引用时一定要将其初始化成某个变量&lt;/li&gt;
&lt;li&gt;引用初始化后,不能再改变其引用的对象&lt;/li&gt;
&lt;li&gt;引用只能引用变量,不能引用常量和表达式&lt;/li&gt;
&lt;li&gt;常引用:不能通过引用修改原值&lt;/li&gt;
&lt;li&gt;常量指针:不能通过常量指针修改其指向的内容;不能把常量指针赋值给非常量指针,反过来可以;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;动态内存分配&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;int *p = new int;&lt;/li&gt;
&lt;li&gt;int *p = new int[20];&lt;/li&gt;
&lt;li&gt;delete p;释放的只能是new出来的空间&lt;/li&gt;
&lt;li&gt;delete []p;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;函数重载:名字相同,参数个数或参数类型不同&lt;/h3&gt;

&lt;h3&gt;缺省参数:&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;void F(int x, int y=1, int z=2){}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;private:基类的成员函数和友元函数&lt;/li&gt;
&lt;li&gt;public:基类成员/友元,派生类成员/友元,其他函数&lt;/li&gt;
&lt;li&gt;protected:基类成员/友元函数,派生类成员函数&lt;/li&gt;
&lt;li&gt;缺省默认为&lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写在类定义内部的函数,成为内联成员函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;构造函数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;构造函数中不能用&lt;code&gt;this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Point P&lt;/li&gt;
&lt;li&gt;构造函数在分配实例的内存之后&lt;/li&gt;
&lt;li&gt;对象数组的初始化
Test array[3]={1,Test(1,2)};
array[0]用Test(1)初始化;array[1]用Test(1,2)初始化;array[2]用Test()初始化&lt;/li&gt;
&lt;li&gt;初始化列表:&lt;code&gt;Point(int m, int n):x(m),y(n){};&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;复制构造函数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Point p(p2)&lt;/li&gt;
&lt;li&gt;复制构造函数的参数是类的&lt;code&gt;引用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;起作用的三种情况

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Point p(p1)&lt;/code&gt; 或者 &lt;code&gt;Point p=p1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某函数的参数是类的对象,则类的复制构造函数被调用&lt;/li&gt;
&lt;li&gt;函数的返回值是类的对象,函数返回时,复制构造函数被调用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;类型转换构造函数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Point P = 11&lt;/code&gt;或&lt;code&gt;Point P; P=11;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Point(int i){x=i;y=0;}&lt;/li&gt;
&lt;li&gt;可以看到等号右边的&lt;code&gt;int&lt;/code&gt;被转换成了&lt;code&gt;Point&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要注意的是,这里会调用一次析构函数,因为转换的步骤是

&lt;ul&gt;
&lt;li&gt;用类型转换构造函数生成一个&lt;code&gt;临时&lt;/code&gt;实例&lt;code&gt;temp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将temp给P&lt;/li&gt;
&lt;li&gt;析构temp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;析构函数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;~Point(){delet []x;};&lt;/li&gt;
&lt;li&gt;缺省析构函数不释放用户申请的内存&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;因为构造函数和析构函数的不对等(构造函数的方法比析构多),所以构造函数和析构函数处理&lt;code&gt;全局&lt;/code&gt;/&lt;code&gt;静态&lt;/code&gt;变量时,需要额外注意&lt;/h3&gt;

&lt;h3&gt;静态成员&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;静态成员变量,所有对象共享&lt;/li&gt;
&lt;li&gt;sizeof不计算静态成员变量&lt;/li&gt;
&lt;li&gt;静态成员变量需要在(定义类的文件中)声明或初始化&lt;/li&gt;
&lt;li&gt;静态成员不需要用过对象访问

&lt;ul&gt;
&lt;li&gt;Point::F()&lt;/li&gt;
&lt;li&gt;Point p; p.F();其他类似的指针和引用皆可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;静态成员函数中不能访问非静态成员变量和调用非静态成员函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;友元&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;友元函数:可以访问类的私有成员,声明在类内部&lt;/li&gt;
&lt;li&gt;友元类:A的友元类B中的任何函数能访问A的私有成员

&lt;ul&gt;
&lt;li&gt;友元类没有传递和继承关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;运算符重载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;赋值运算符&amp;#39;=&amp;#39;只能重载为成员函数&lt;/li&gt;
&lt;li&gt;返回类型为&lt;code&gt;对象的引用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;浅复制和深复制,以两个指向str的对象为例

&lt;ul&gt;
&lt;li&gt;浅复制将指针的值复制过去,导致两个对象指向同一内存空间&lt;/li&gt;
&lt;li&gt;深复制将指针指向的内容复制过去&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;返回值类型 operator 运算符(形参表){
    ...
}
Point operator+(const Point &amp;amp;a, const Point &amp;amp;b){
    return Point(a.x+b.x,a.y+b.y);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;继承&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;子类继承了基类的所有成员,但是不能访问基类的private成员&lt;/li&gt;
&lt;li&gt;子类空间大小包含基类空间大小,基类对象存储位置在子类成员前面&lt;/li&gt;
&lt;li&gt;子类和父类存在同名成员时,加上域作用符&lt;code&gt;base::F()&lt;/code&gt;来区别是父类还是子类的成员&lt;/li&gt;
&lt;li&gt;派生类的构造函数调用之前先调用基类的构造函数&lt;/li&gt;
&lt;li&gt;公有派生

&lt;ul&gt;
&lt;li&gt;子类对象可以赋值给基类对象&lt;/li&gt;
&lt;li&gt;子类对象可以用基类引用&lt;/li&gt;
&lt;li&gt;基类指针可以指向子类对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class subC: public C{

};
子类的构造函数
subC(int x, int y, int z):C(x, y){zz=z;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;复合关系&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-CPP&quot; data-lang=&quot;CPP&quot;&gt;    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CMaster&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CDog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CMaster&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CMaster&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CDog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;多态&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;类的定义中函数前面加&lt;code&gt;virtual&lt;/code&gt;关键字,将其声明为虚函数&lt;/li&gt;
&lt;li&gt;构造函数和静态成员函数不能是虚函数&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;基类指针/引用&lt;/code&gt;调用基类或派生类中同名&lt;code&gt;虚函数&lt;/code&gt;时:

&lt;ul&gt;
&lt;li&gt;若指针指向一个基类对象,调用的是基类的虚函数&lt;/li&gt;
&lt;li&gt;若指针指向的是一个派生类的对象,调用的是派生类的虚函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;引用&lt;/code&gt;同理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多态通过&lt;code&gt;动态联编&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;每个有&lt;code&gt;虚函数&lt;/code&gt;的类任何一个对象都有一个&lt;code&gt;虚函数表&lt;/code&gt;的指针(四个字节),虚函数表存放虚函数的地址.所以,编译的时候,根据虚函数表调用实际函数&lt;/li&gt;
&lt;li&gt;多态,增加了额外时间和空间开销&lt;/li&gt;
&lt;li&gt;虚析构函数:多态的情况下,要注意将析构函数也虚函数化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual void F()=0;&lt;/code&gt;纯虚函数&lt;/li&gt;
&lt;li&gt;包含纯虚函数的类被称为抽象类,抽象类不能被实例化,只能用指针和引用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-CPP&quot; data-lang=&quot;CPP&quot;&gt;    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Point&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SubPoint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SubPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;SubPoint&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 基类析构函数已经声明为虚函数了,派生类就不用再声明了&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SubPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 这里没写虚析构函数的话,就会有问题,只调用了基类的虚构函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Roliy机器学习de资源目录</title>
      <link>place_your_blog_url_here/ml/2014/07/25/MLres.html</link>
      <pubDate>25 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ml/2014/07/25/MLres</guid>
      <description>&lt;p&gt;这里是Roliy的机器学习相关资源和推荐的地方~&lt;/p&gt;

&lt;h2&gt;书籍&lt;/h2&gt;

&lt;h4&gt;不得不说,个人看过的ML的书真是一只手就能数过来,这里就说说个人非常喜欢的一些吧&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://book.douban.com/subject/10590856/&quot;&gt;统计学习方法&lt;/a&gt;&lt;/strong&gt;,李航的这本&lt;code&gt;又小又薄&lt;/code&gt;的书满满的都是算法,对于简单粗暴、就喜欢算法和怎么实现的我来说,简直再适合不过了。加之其中用到的数学推导过程基本上不超过CS的数学范畴,看起来也不啥费劲。力荐之~&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;论文&lt;/h2&gt;

&lt;h2&gt;网站&lt;/h2&gt;

&lt;h4&gt;有些是个人blog,有些是...&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://beader.me/mlnotebook/&quot;&gt;机器学习基石-笔记&lt;/a&gt;,blog主的名字不太清楚,但是这套笔记的质量很高,内容概括得也很全,推荐之~&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;数据集&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Roliy常用的Git命令</title>
      <link>place_your_blog_url_here/sf/2014/07/25/Git.html</link>
      <pubDate>25 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/sf/2014/07/25/Git</guid>
      <description>&lt;p&gt;这里是Roliy的Git命令备忘录,不是很适合新手.对于想学Git的爱好者,强烈推荐&lt;a href=&quot;http://book.douban.com/subject/4813786/&quot;&gt;版本控制之道&lt;/a&gt;.你会找到你需要的东西~&lt;/p&gt;

&lt;h3&gt;安装之后初始化&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;config --global user.name &amp;quot;XXXXXXX&amp;quot;               # set username
config --global user.email &amp;quot;XXXX@XXX.com&amp;quot;         # set email
config --global --list                            # 显示全局设置
config --global color.ui &amp;quot;auto&amp;quot;/&amp;quot;false&amp;quot;/&amp;quot;true&amp;quot;    # 使用不同颜色显示不同类型的内容
config --global core.editor gvim.exe              # 将gvim设置为commit留言调用的编辑器,前提是gvim已经在环境变量里了
git config --global merge.tool kdiff3
git config --global mergetool.kdiff3.path &amp;quot;C:\Program Files\KDiff3\kdiff3.exe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建仓库和提交更新&lt;/h3&gt;

&lt;p&gt;个人理解：Git管理了三个空间,一个是实际硬盘空间/工作区,直接修改源文件的地方;一个是暂存区,也就是执行了add命令之后文件存在的地方;最后一个是版本仓库,也就是使用了commit命令之后文件存在的地方.   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mkdir foldername                #这个是命令行创建文件夹命令嘛
cd foldername
git init                        #在文件夹目录下新建仓库
git add filename.xx             #把文件添加到仓库中,前提是该文件在目录下
git commit -m &amp;quot;add in hello&amp;quot;    #提交更  
在源文件修改之后使用：
git status                      #查看修改状态,会有红色标注,这时候使用：
git add index.html              #再使用git status,文件会变成绿色,这时候使用：
git commit -m &amp;quot;add &amp;lt;head&amp;gt; and &amp;lt;title&amp;gt; to index&amp;quot;
add -i                          #进入交互模式,详解
1:status    2:update    3:revert    4:add untracked
5:patch     6:diff      7:quit      8:help
add untracked   #添加未被git跟踪的文件到暂存区
updata          #将被修改的文件(已被跟踪)加进暂存区
revert          #将暂存区中的文件去掉,相当于取消add操作
patch           #针对文件中被修改的块执行添加缓冲区询问和操作
add -p          #直接进入patch模式
git stash       #将当前工作区的修改推入栈中,工作区还原成最近一次commit的状态          
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分支&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git checkout -b x1 x2           #从x1分支创建x2分支,并切换到x2,与下两条指令合在一起等价
git branch x1 x2                #从父分支x2创建分支x1，没有使用切换分支指令前，修改源文件,提交：
git checkout x1                 #切换到之前创建的分支x1,这里认为,切换分支之前的修改提交是作用于“创建了x1分支的x2分支上
                                #的”而x1分支则完全是x2分支(未修改)的拷贝.当然,如果修改发生在切换分支之后,则又不一样
                                #了.切换到未修改的分支之后,所有源文件将会回复到原来状态.切换分支之后的修改相当于在“回
                                #到过去”的原文件上修改.
git checkout master             
git rebase x1                   #将x1分支上的所有提交复制到当前分支上,此命令执行后,当前分支和x1分支一模一样
git branch -d x1                #然后就可以删除x1分支了,大写D更强力一些
git branch                      #显示分支名称,带*号的是当前分支
git tag 1.0 x1                  #第一个参数是版本号,第二个参数是分支名.整个标签的意思是给(截至到目前所有文件修改到)
                                #x1分支做一个版本号标记
git tag                         #查看所有版本号
git branch x1.1 1.0             #从标签1.0创建分支x1.1
git merge x2                    #将x2分支的所有修改合并到当前分支
                                #原文件状态是X,创建两条分支X1和X2,并在分支上修改,若要将X和X1或X2合并,则OK,若X1和X2分支
                                #对同一个文件做了修改,将X1和X2合并时就会产生冲突.
git mergr --squash x2           #相当于仅把x2分支内容提交到暂存区,之后还需要commit指令提交  
git branch -m name1 name2       #把name1改成name2,大写的M更强力
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;版本回溯&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git revert 版本号                #撤销修改,版本号最好是前一个提交的版本号,这样不用处理冲突...
git reset --hard 版本号  复位操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;打包&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git archive --format=zip --prefix=mysite-1.0/1.0 | gzip &amp;gt; mysite-1.0.zip
git archive --format=tar --prefix=mysite-1.0/1.0 | gzip &amp;gt; mysite-1.0.tar.gz
#两种打包压缩,第一种压缩成zip第二种压缩成gz;format的参数表明压缩类型,prefix参数表明目标目录,最后一部分表明压缩文件名称
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看日志&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git log                         #查看修改日志,可以加上&amp;#39;-具体数字&amp;#39;参数表示需要显示的条数
git log -p                      #按照日志顺序显示版本间差异
git log number                  #根据哈希码查看日志,前七位即可
git log --since=&amp;quot;5 hours&amp;quot;       #查看5个小时内的提交记录
git log number1...number2       #查看版本number1到number2之间的版本记录
git blame file                  #按行输出file,每行前面会写该行提交的版本号和提交者,提交时间等
git blame -L number1,number2 file #查看num1到num2行的记录
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;文件开始状态为X1,修改之后为X2,此时使用add命令;再次修改源文件,状态为X3;也就是说版本库里文件是X1状态,暂存区文件是X2状态,实际硬盘上是X3状态,使用：
git diff                        #将暂存区文件X2和硬盘文件X3做比较
git diff --cached               #将暂存区X2和版本库X1做比较
git diff head                   #将硬盘X3和版本库X1做比较
git diff number                 #number是版本号,将当前状态和该版本比较
git mv name1 name2              #将文件名name1改成name2,相当于(在硬盘上改名,并执行了add指令),但仍需要conmit指令提交到版本库
初始状态为X,提交之后需要修改X,但是需要把两次修改作为一次提交(比如一些错误比较低级,不想让别人知道)：
git commit -C head -a -amend
git reset HEAD                  #复位HEAD提交,相当与删除了最新的一个提交记录,实际文件没有什么变化
git gc                          #整理版本库,清理一些垃圾,根据提交日志,日志里没有的东西都会被删除.比如,之前复位了一些版本,文件还存在于硬盘上,执行本操作之后就复位的日志记录之后的修改都被删除了.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;设置.gitignore文件&lt;/h3&gt;

&lt;p&gt;通过设置.gitignore文件来忽略跟踪满足特定规则的文件
Windows下命名为 .gitignore.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fd1/*           忽略所有名字是fd1的目录下的全部内容
filename*       忽略所有filenameXXX的文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;冲突&lt;/h3&gt;

&lt;p&gt;当合并或其他时候就会遇到冲突,下面是某文本块冲突的实例&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;xxx
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:filename
    This is an apple
=====
    This is a banana
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; filename
xxx
一对&amp;#39;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;#39;和&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;#39;将冲突的文本块标记出来,&amp;#39;====&amp;#39;将修改后和修改前分割开
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改量少的话,可以直接依据上面的提示做编辑,复杂的话,使用    &lt;code&gt;git mergetool&lt;/code&gt; 打开合并工具,图形化合并文件.&lt;/p&gt;

&lt;h3&gt;网络通信&lt;/h3&gt;

&lt;h4&gt;三种方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;SSH  git@github.com:roliygu/RoliyOS.git 安全&lt;/li&gt;
&lt;li&gt;git  git://github.com/roliygu/RoliyOS.git 据说速度最快&lt;/li&gt;
&lt;li&gt;HTTP https://github.com/roliygu/RoliyOS.git 需要修改防火墙,不过我用着没改&lt;/li&gt;
&lt;li&gt;pull和fetch的区别,前者从远程仓库取过来并合并到本地分支,后者只是取过来更新远程分支&lt;/li&gt;
&lt;li&gt;pull命令带两个参数,远程版本库名称&lt;code&gt;origin&lt;/code&gt;即可,合并到本地分支&lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Welcome to Jekyll!</title>
      <link>place_your_blog_url_here/sf/2014/07/24/welcome-to-jekyll.html</link>
      <pubDate>24 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/sf/2014/07/24/welcome-to-jekyll</guid>
      <description>&lt;p&gt;You&amp;#39;ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory - edit this post and re-build (or run with the &lt;code&gt;-w&lt;/code&gt; switch) to see your changes!
To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention: YYYY-MM-DD-name-of-post.ext.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll&amp;#39;s GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>