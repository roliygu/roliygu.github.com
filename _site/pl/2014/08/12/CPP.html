<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>CPP备忘录</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>

  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有</li>
          <li id="js-label2" class="tags__li tags-btn">编程语言</li>
          <li id="js-label3" class="tags__li tags-btn">机器学习</li>
          <li id="js-label4" class="tags__li tags-btn">各种软件</li>
          <li id="js-label5" class="tags__li tags-btn">我的项目</li>
          <li id="js-label6" class="tags__li tags-btn">随笔</li>
        </ul>

      </nav> <!-- end #tags -->

      <div id="posts-list">
        <nav id="pl__container">
        
          <a class="pl pl__all" href="/pl/2014/08/12/CPP.html"><span class="pl__circle"></span><span class="pl__title">CPP备忘录</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="ml pl__all" href="/ml/2014/07/25/MLres.html"><span class="pl__circle"></span><span class="pl__title">Roliy机器学习de资源目录</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="sf pl__all" href="/sf/2014/07/25/Git.html"><span class="pl__circle"></span><span class="pl__title">Roliy常用的Git命令</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="sf pl__all" href="/sf/2014/07/24/welcome-to-jekyll.html"><span class="pl__circle"></span><span class="pl__title">Welcome to Jekyll!</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140812">CPP备忘录</h1>
  <h2>程序设计实践笔记</h2>

<h3>函数指针</h3>

<ul>
<li><code>类型 (*指针变量名)(参数类型1, 参数类型2,...);</code></li>
<li>例如,快速排序<code>qsort</code>的第三个参数就是函数指针</li>
</ul>

<p>代码</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int min(int a,int b){return a&lt;b;}
int (*pf)(int, int);
pf = min;
pf(1,2)             //函数指针名(实参表)
</code></pre></div>
<ul>
<li>C语言中的qsort函数

<ul>
<li><code>void qsort(void *base, int nelem, unsigned int width,int(*pfCompare)(const void *,const void *))</code></li>
<li>比较函数编写规则

<ul>
<li>elem1排在elem2前面,返回值为负整数</li>
<li>相等,返回0</li>
<li>排在后面,返回正整数</li>
</ul></li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-CPP" data-lang="CPP">    <span class="kt">int</span> <span class="nf">myCompare</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">elem1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">elem2</span><span class="p">){</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="o">*</span><span class="n">p2</span><span class="p">;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">elem1</span><span class="p">;</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">elem2</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p1</span> <span class="o">%</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="o">*</span><span class="n">p2</span> <span class="o">%</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cp">#define Num 5</span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">an</span><span class="p">[</span><span class="n">Num</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">123</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
        <span class="n">qsort</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">Num</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">),</span> <span class="n">myCompare</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">Num</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="n">an</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<h3>命令行参数</h3>

<ul>
<li>argc:代表命令行参数的个数,包括程序名;</li>
<li>argv:指针数组,其中每个元素都是一个<code>char *</code>,argv[i]指向第i个参数</li>
</ul>

<p>代码</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">int main(int argc, char *argv[]){
    xxx;
}
</code></pre></div>
<h3>位运算(6种)</h3>

<ul>
<li><code>n = n &amp; 0xffffff00;</code> 将低8位置成0</li>
<li>n&amp;=0xff00; n是short型</li>
<li><code>x &amp; 0x80 == 0x80</code> x的第8位是否为1</li>
<li><code>n ^= 0xff</code> 低8位取反</li>
<li>a^b=c 那么 c^b=a,c^a=b</li>
<li>~位取反</li>
</ul>

<h3>引用</h3>

<ul>
<li>定义引用时一定要将其初始化成某个变量</li>
<li>引用初始化后,不能再改变其引用的对象</li>
<li>引用只能引用变量,不能引用常量和表达式</li>
<li>常引用:不能通过引用修改原值</li>
<li>常量指针:不能通过常量指针修改其指向的内容;不能把常量指针赋值给非常量指针,反过来可以;</li>
</ul>

<h3>动态内存分配</h3>

<ul>
<li>int *p = new int;</li>
<li>int *p = new int[20];</li>
<li>delete p;释放的只能是new出来的空间</li>
<li>delete []p;</li>
</ul>

<h3>函数重载:名字相同,参数个数或参数类型不同</h3>

<h3>缺省参数:</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">void F(int x, int y=1, int z=2){}
</code></pre></div>
<h3>类</h3>

<ul>
<li>private:基类的成员函数和友元函数</li>
<li>public:基类成员/友元,派生类成员/友元,其他函数</li>
<li>protected:基类成员/友元函数,派生类成员函数</li>
<li>缺省默认为<code>private</code></li>
<li>写在类定义内部的函数,成为内联成员函数</li>
</ul>

<h4>构造函数</h4>

<ul>
<li>构造函数中不能用<code>this</code></li>
<li>Point P</li>
<li>构造函数在分配实例的内存之后</li>
<li>对象数组的初始化
Test array[3]={1,Test(1,2)};
array[0]用Test(1)初始化;array[1]用Test(1,2)初始化;array[2]用Test()初始化</li>
<li>初始化列表:<code>Point(int m, int n):x(m),y(n){};</code></li>
</ul>

<h4>复制构造函数</h4>

<ul>
<li>Point p(p2)</li>
<li>复制构造函数的参数是类的<code>引用</code></li>
<li>起作用的三种情况

<ol>
<li><code>Point p(p1)</code> 或者 <code>Point p=p1</code></li>
<li>某函数的参数是类的对象,则类的复制构造函数被调用</li>
<li>函数的返回值是类的对象,函数返回时,复制构造函数被调用</li>
</ol></li>
</ul>

<h4>类型转换构造函数</h4>

<ul>
<li><code>Point P = 11</code>或<code>Point P; P=11;</code></li>
<li>Point(int i){x=i;y=0;}</li>
<li>可以看到等号右边的<code>int</code>被转换成了<code>Point</code></li>
<li>需要注意的是,这里会调用一次析构函数,因为转换的步骤是

<ul>
<li>用类型转换构造函数生成一个<code>临时</code>实例<code>temp</code></li>
<li>将temp给P</li>
<li>析构temp</li>
</ul></li>
</ul>

<h4>析构函数</h4>

<ul>
<li>~Point(){delet []x;};</li>
<li>缺省析构函数不释放用户申请的内存</li>
</ul>

<h3>因为构造函数和析构函数的不对等(构造函数的方法比析构多),所以构造函数和析构函数处理<code>全局</code>/<code>静态</code>变量时,需要额外注意</h3>

<h3>静态成员</h3>

<ul>
<li><code>static</code>关键字</li>
<li>静态成员变量,所有对象共享</li>
<li>sizeof不计算静态成员变量</li>
<li>静态成员变量需要在(定义类的文件中)声明或初始化</li>
<li>静态成员不需要用过对象访问

<ul>
<li>Point::F()</li>
<li>Point p; p.F();其他类似的指针和引用皆可</li>
</ul></li>
<li>静态成员函数中不能访问非静态成员变量和调用非静态成员函数</li>
</ul>

<h3>友元</h3>

<ul>
<li>友元函数:可以访问类的私有成员,声明在类内部</li>
<li>友元类:A的友元类B中的任何函数能访问A的私有成员

<ul>
<li>友元类没有传递和继承关系</li>
</ul></li>
</ul>

<h3>运算符重载</h3>

<ul>
<li>赋值运算符&#39;=&#39;只能重载为成员函数</li>
<li>返回类型为<code>对象的引用</code></li>
<li>浅复制和深复制,以两个指向str的对象为例

<ul>
<li>浅复制将指针的值复制过去,导致两个对象指向同一内存空间</li>
<li>深复制将指针指向的内容复制过去</li>
</ul></li>
</ul>

<p>模式</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">返回值类型 operator 运算符(形参表){
    ...
}
Point operator+(const Point &amp;a, const Point &amp;b){
    return Point(a.x+b.x,a.y+b.y);
}
</code></pre></div>
<h3>继承</h3>

<ul>
<li>子类继承了基类的所有成员,但是不能访问基类的private成员</li>
<li>子类空间大小包含基类空间大小,基类对象存储位置在子类成员前面</li>
<li>子类和父类存在同名成员时,加上域作用符<code>base::F()</code>来区别是父类还是子类的成员</li>
<li>派生类的构造函数调用之前先调用基类的构造函数</li>
<li>公有派生

<ul>
<li>子类对象可以赋值给基类对象</li>
<li>子类对象可以用基类引用</li>
<li>基类指针可以指向子类对象</li>
</ul></li>
</ul>

<p>代码:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class subC: public C{

};
子类的构造函数
subC(int x, int y, int z):C(x, y){zz=z;}
</code></pre></div>
<h3>复合关系</h3>
<div class="highlight"><pre><code class="language-CPP" data-lang="CPP">    <span class="k">class</span> <span class="nc">CMaster</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">CDog</span><span class="p">{</span>
        <span class="n">CMaster</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">CMaster</span><span class="p">{</span>
        <span class="n">CDog</span> <span class="o">*</span><span class="n">dogs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div>
<h3>多态</h3>

<ul>
<li>类的定义中函数前面加<code>virtual</code>关键字,将其声明为虚函数</li>
<li>构造函数和静态成员函数不能是虚函数</li>
<li>通过<code>基类指针/引用</code>调用基类或派生类中同名<code>虚函数</code>时:

<ul>
<li>若指针指向一个基类对象,调用的是基类的虚函数</li>
<li>若指针指向的是一个派生类的对象,调用的是派生类的虚函数</li>
<li><code>引用</code>同理</li>
</ul></li>
<li>多态通过<code>动态联编</code>实现</li>
<li>每个有<code>虚函数</code>的类任何一个对象都有一个<code>虚函数表</code>的指针(四个字节),虚函数表存放虚函数的地址.所以,编译的时候,根据虚函数表调用实际函数</li>
<li>多态,增加了额外时间和空间开销</li>
<li>虚析构函数:多态的情况下,要注意将析构函数也虚函数化</li>
<li><code>virtual void F()=0;</code>纯虚函数</li>
<li>包含纯虚函数的类被称为抽象类,抽象类不能被实例化,只能用指针和引用</li>
</ul>
<div class="highlight"><pre><code class="language-CPP" data-lang="CPP">    <span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">Point</span><span class="p">(){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Point&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">SubPoint</span><span class="o">:</span><span class="k">public</span> <span class="n">Point</span><span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="o">~</span><span class="n">SubPoint</span><span class="p">(){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;SubPoint&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span> <span class="c1">// 基类析构函数已经声明为虚函数了,派生类就不用再声明了</span>
    <span class="p">}</span>
    <span class="n">Point</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubPoint</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// 这里没写虚析构函数的话,就会有问题,只调用了基类的虚构函数</span>
</code></pre></div>
</article> <!-- end #post__content -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;My GitHub <a href="https://github.com/roliygu" target="_blank">RoliyGu</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
  </body>
</html>